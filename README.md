# adoctl

Azure DevOps decomposition outbox + writer CLI.

This tool is designed to take **agent-generated decompositions** (Features + User Stories) in a canonical JSON “bundle” format, validate them against **team policy** and **ADO-derived metadata**, then bulk-create the work items in Azure DevOps safely.

## Quickstart

Assumes:

- conda `4.9.2`
- Python `3.8.5`

- Create conda env: `conda env create --offline -f environment.yml`
- Activate: `conda activate adoctl`
- Run: `python -m adoctl sync --help`

If you want an `adoctl` executable in the env:

- `pip install -e .`

## Repository Layout

### `adoctl/`

Python package for the CLI and supporting modules.

- `adoctl/cli/` — CLI entrypoints and argument parsing.
- `adoctl/ado_client/` — ADO REST client primitives (auth, HTTP, config models).
- `adoctl/sync/` — “sync” implementation (ADO → `config/generated/*`).
- `adoctl/config/` — repo path helpers and config composition utilities (will expand).
- `adoctl/util/` — small utilities (filesystem, formatting, etc.).

### `config/`

Layered configuration (do not mix responsibilities between layers).

- `config/policy/` — team governance rules (human-authored).
  - `link_policy.yaml` — allowed link types and hierarchy rules.
  - `standards.yaml` — naming/tagging conventions.
  - `field_policy.yaml` — required/allowed canonical fields, agent export scope, and description section requirements.
  - `field_map.yaml` — canonical field key -> ADO reference name mapping.
  - `wit_map.yaml` — canonical work item type -> ADO work item type mapping.
  - `kr_taxonomy.yaml` — KR taxonomy used for tags/governance.
- `config/generated/` — ADO-derived facts (generated by `adoctl sync`; never hand-edit).
  - `projects.yaml` — org projects snapshot.
  - `teams.yaml` — teams for the selected project.
  - `paths_area.yaml` — flattened Area paths.
  - `paths_iteration.yaml` — flattened Iteration paths.
  - `planning_context.yaml` — team-scoped allowed paths + Objective/Key Result semantics.
  - `planning_sync_dump.json` — raw ADO planning metadata dump used to derive planning semantics.
  - `wit_contract.yaml` — work item type fields and metadata.
  - `_sync_state.yaml` — sync metadata (timestamps, version, sections).
- `config/local/` — local operator context for CLI UX.
  - `context.yaml` — selected org/project/team/current iteration used by the home screen and defaults.

## Configuration Lineage and Ownership

Edit policy and local context; do not hand-edit generated artifacts.

- Safe to edit (user-managed):
  - `config/policy/wit_map.yaml`
  - `config/policy/field_map.yaml`
  - `config/policy/field_policy.yaml`
  - `config/policy/link_policy.yaml`
  - `config/policy/standards.yaml`
  - `config/policy/kr_taxonomy.yaml`
  - `config/local/context.yaml` (optional; CLI may overwrite)
- Do not edit (machine-generated):
  - `config/generated/wit_contract.yaml`
  - `config/generated/wit_contracts/*.yaml`
  - `config/generated/_sync_state.yaml`
  - `config/generated/agent_contract.yaml`
  - `config/generated/contract_lint.yaml` (when emitted)

Lineage:

```text
ADO metadata (sync/bootstrap) -----> config/generated/wit_contract*.yaml
                                      |
User policy edits ----------------> config/policy/*.yaml
                                      |
                                      v
                             adoctl contract export
                                      |
                                      v
                         config/generated/agent_contract.yaml
                                      |
                      Agent canonical bundle JSON output
                                      |
                     Must satisfy schema + exported contract
```

### `schema/`

Machine-readable contracts.

- `schema/bundle.schema.json` — JSON Schema for the canonical outbox bundle format.

### `outbox/`

File-based workflow for bundles.

- `outbox/ready/` — agent drops bundles here.
- `outbox/validated/` — bundles that pass `adoctl outbox validate`.
- `outbox/failed/` — bundles that fail validation + `*.report.yaml`.
- `outbox/archived/` — bundles successfully written and archived after `adoctl write`.
- `outbox/_written_work_items.yaml` — machine-generated registry of `local_id -> ado_id` for written items.

### `audit/`

Structured audit artifacts emitted by `adoctl write` (one file per run).

### `logs/`

Local log output (future: structured logs + redaction).

### Root files

- `environment.yml` — conda environment (pinned to Python `3.8.5`).
- `pyproject.toml` — packaging + CLI script definition (`adoctl`).
- `docs/specs.md` — system specification and intended behavior.
- `AGENTS.md` — engineering constraints and the canonical bundle contract.

## Typical Developer Workflow

1) Sync ADO metadata into generated configs:

- Set PAT in env: `export ADO_PAT="..."`
- Run sync:
  - `python -m adoctl sync --org-url "https://dev.azure.com/<ORG>" --project "<PROJECT>" --all`
  - Planning-only sync (teams + team paths + Objective/Key Result semantics):
    - `python -m adoctl sync --org-url "https://dev.azure.com/<ORG>" --project "<PROJECT>" --planning-only`

Optional home/context UX:

- Run `python -m adoctl` (or `python -m adoctl home`) to open the home screen menu.
- Use `python -m adoctl context show` to view saved context.
- Use `python -m adoctl context set --team "<TEAM>"` to update context non-interactively.

Bootstrap WIT contracts from extracted JSON:

- Run `python -m adoctl bootstrap-wit-contracts --input data.json --out-dir config/generated`
- This writes:
  - `config/generated/wit_contract.yaml` (aggregate contract)
  - `config/generated/wit_contracts/*.yaml` (one contract per work item type)

Export effective agent contract:

- Run `python -m adoctl contract export --out config/generated/agent_contract.yaml`
- This writes a single contract snapshot composed of:
  - policy mappings (`config/policy/wit_map.yaml`, `config/policy/field_map.yaml`)
  - field policy (`config/policy/field_policy.yaml`)
  - generated ADO metadata (`config/generated/wit_contract.yaml`)
- Precedence rule:
  - any canonical field mapped to an ADO-required field in `wit_contract.yaml` is promoted into `field_policy.yaml.required_fields`.
  - `field_policy.yaml` can still be stricter by requiring additional canonical fields.
- Policy controls:
  - `agent_contract_export.include_work_item_types` controls which policy types are emitted into `agent_contract.yaml`.
  - `description_required_sections` / `description_optional_sections` capture requirements that live inside `Description` (or discussion-style content), not standalone ADO fields.

Lint contract consistency (offline):

- Run `python -m adoctl contract lint --policy-dir config/policy --generated-dir config/generated`
- Optional report file: `python -m adoctl contract lint --out config/generated/contract_lint.yaml`
- Lint checks:
  - policy field keys/types align with `field_map.yaml` and `wit_map.yaml`
  - mapped ADO reference names exist in `config/generated/wit_contract.yaml`
  - standards-required mapped fields exist in `field_policy.required_fields`
  - non-export policy/standards types are reported as informational findings
- Exit code:
  - `0` when no errors
  - `2` when errors are present

Bootstrap policy metadata from team wiki docs (one-time seed):

- Run `python -m adoctl policy bootstrap-from-docs --docs-dir docs --out config/policy/field_policy.yaml`
- This adds `wiki_required_metadata`, `wiki_optional_metadata`, and `wiki_source_docs` sections to `field_policy.yaml`.
- Runtime canonical policy keys (`allowed_fields`, `required_fields`) are preserved and remain the enforcement source.

2) Validate outbox bundles:

- Run `python -m adoctl outbox validate --all`
- Or run `python -m adoctl outbox validate outbox/ready/<bundle>.json`
- Validation order is strict and gated:
  - schema (`schema/bundle.schema.json`)
  - policy (link rules, required fields, local_id uniqueness)
  - metadata (wit/field mapping + area/iteration path resolvability)
- Failure behavior:
  - write `outbox/failed/<bundle>.report.yaml`
  - move bundle to `outbox/failed/` when validating from `outbox/ready/`
- Success behavior:
  - move bundle to `outbox/validated/` when validating from `outbox/ready/`
- Exit code:
  - `0` when all processed bundles pass
  - `2` when one or more bundles fail

3) Write validated bundles:

- Dry-run planning:
  - `python -m adoctl write --all-validated --dry-run --org-url "https://dev.azure.com/<ORG>" --project "<PROJECT>"`
  - prints a resolved method + URL plan for each create/link operation
  - writes an audit file under `audit/` with simulated IDs and request payloads
- Real write:
  - `python -m adoctl write --all-validated --org-url "https://dev.azure.com/<ORG>" --project "<PROJECT>"`
  - creates Features first, then User Stories
  - skips create for local IDs already present in `outbox/_written_work_items.yaml`
  - links each created item to `relations.parent_local_id` using parent-child hierarchy links only
  - resolves parent links from in-run creates, registry local IDs, or numeric ADO IDs
  - stops on first error and writes audit with failure reason
  - archives successfully written bundles from `outbox/validated/` to `outbox/archived/`

4) Replicate planning semantics into external instruction set:

- Copy generated planning context after sync:
  - `cp config/generated/planning_context.yaml instruction_set/contracts/planning_context.yaml`
